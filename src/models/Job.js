const mongoose = require('mongoose');
const { encoderDb } = require('../config/database');

// ============================================
// 3SPEAK ENCODER JOB SCHEMA
// ============================================
// This schema matches the exact structure expected by the existing encoder system
const jobSchema = new mongoose.Schema({
  // ============================================
  // JOB IDENTITY
  // ============================================
  id: { 
    type: String, 
    required: true, 
    unique: true,
    index: true
  }, // UUID generated by service
  
  // ============================================
  // JOB METADATA
  // ============================================
  created_at: { 
    type: Date, 
    default: Date.now,
    index: true
  },
  status: { 
    type: String, 
    default: 'queued',
    enum: [
      'queued',
      'running', 
      'completed',
      'failed',
      'cancelled'
    ],
    index: true
  },
  start_date: Date,
  last_pinged: { 
    type: Date,
    index: true
  },
  completed_at: Date,
  assigned_to: String, // DID - filled by encoder when claimed
  assigned_date: Date,
  
  // ============================================
  // VIDEO LINKING METADATA
  // ============================================
  metadata: {
    video_owner: { 
      type: String,
      required: true,
      index: true
    },
    video_permlink: { 
      type: String,
      required: true,
      index: true
    }
  },
  
  // ============================================
  // STORAGE METADATA
  // ============================================
  storageMetadata: {
    app: { 
      type: String, 
      default: '3speak' 
    },
    key: String, // Format: "owner/permlink/video"
    type: { 
      type: String, 
      default: 'video' 
    }
  },
  
  // ============================================
  // INPUT FILE CONFIGURATION
  // ============================================
  input: {
    uri: { 
      type: String, 
      required: true 
    }, // Gateway URL for download
    size: { 
      type: Number, 
      required: true,
      min: 1000 // Minimum 1KB
    }
  },
  
  // ============================================
  // ENCODER RESULTS (FILLED BY ENCODER)
  // ============================================
  result: mongoose.Schema.Types.Mixed, // Encoder fills this with output metadata
  progress: mongoose.Schema.Types.Mixed, // Encoder fills this with progress info
  
  // ============================================
  // ERROR TRACKING
  // ============================================
  error_message: String,
  retry_count: { 
    type: Number, 
    default: 0 
  },
  max_retries: { 
    type: Number, 
    default: 3 
  }
}, {
  collection: 'jobs', // Explicit collection name
  timestamps: false // Using manual created_at field
});

// ============================================
// INDEXES FOR ENCODER PERFORMANCE
// ============================================
jobSchema.index({ status: 1, created_at: 1 }); // For encoder polling
jobSchema.index({ assigned_to: 1, status: 1 }); // For encoder status checks
jobSchema.index({ 'metadata.video_owner': 1, 'metadata.video_permlink': 1 }); // For video linking
jobSchema.index({ last_pinged: 1 }); // For stale job detection

// ============================================
// VIRTUAL FIELDS
// ============================================
jobSchema.virtual('isActive').get(function() {
  return ['queued', 'running'].includes(this.status);
});

jobSchema.virtual('isComplete').get(function() {
  return ['completed', 'failed', 'cancelled'].includes(this.status);
});

jobSchema.virtual('durationMs').get(function() {
  if (this.start_date && this.completed_at) {
    return this.completed_at.getTime() - this.start_date.getTime();
  }
  return null;
});

jobSchema.virtual('waitTimeMs').get(function() {
  if (this.created_at && this.start_date) {
    return this.start_date.getTime() - this.created_at.getTime();
  }
  return null;
});

// ============================================
// INSTANCE METHODS
// ============================================
jobSchema.methods.updateStatus = function(newStatus, progressData = null) {
  this.status = newStatus;
  this.last_pinged = new Date();
  
  if (newStatus === 'running' && !this.start_date) {
    this.start_date = new Date();
  }
  
  if (['completed', 'failed', 'cancelled'].includes(newStatus) && !this.completed_at) {
    this.completed_at = new Date();
  }
  
  if (progressData) {
    this.progress = progressData;
  }
  
  return this.save();
};

jobSchema.methods.assignTo = function(encoderDid) {
  this.assigned_to = encoderDid;
  this.assigned_date = new Date();
  this.status = 'running';
  this.start_date = new Date();
  this.last_pinged = new Date();
  
  return this.save();
};

jobSchema.methods.markFailed = function(errorMessage) {
  this.status = 'failed';
  this.error_message = errorMessage;
  this.completed_at = new Date();
  this.retry_count = (this.retry_count || 0) + 1;
  
  return this.save();
};

jobSchema.methods.canRetry = function() {
  return (this.retry_count || 0) < this.max_retries;
};

jobSchema.methods.toPublicJSON = function() {
  return {
    id: this.id,
    status: this.status,
    created_at: this.created_at,
    start_date: this.start_date,
    completed_at: this.completed_at,
    assigned_to: this.assigned_to,
    progress: this.progress,
    metadata: this.metadata,
    durationMs: this.durationMs,
    waitTimeMs: this.waitTimeMs
  };
};

// ============================================
// STATIC METHODS
// ============================================
jobSchema.statics.findQueued = function(limit = 50) {
  return this.find({ status: 'queued' })
    .sort({ created_at: 1 }) // FIFO
    .limit(limit);
};

jobSchema.statics.findByEncoder = function(encoderDid, statuses = ['running']) {
  return this.find({
    assigned_to: encoderDid,
    status: { $in: statuses }
  }).sort({ assigned_date: -1 });
};

jobSchema.statics.findStale = function(staleMinutes = 30) {
  const staleDate = new Date();
  staleDate.setMinutes(staleDate.getMinutes() - staleMinutes);
  
  return this.find({
    status: 'running',
    last_pinged: { $lt: staleDate }
  });
};

jobSchema.statics.findByVideo = function(owner, permlink) {
  return this.findOne({
    'metadata.video_owner': owner,
    'metadata.video_permlink': permlink
  }).sort({ created_at: -1 }); // Latest job for this video
};

jobSchema.statics.getStats = function() {
  return this.aggregate([
    {
      $group: {
        _id: '$status',
        count: { $sum: 1 },
        avgDuration: {
          $avg: {
            $cond: [
              { $and: ['$start_date', '$completed_at'] },
              { $subtract: ['$completed_at', '$start_date'] },
              null
            ]
          }
        }
      }
    }
  ]);
};

// ============================================
// PRE-SAVE MIDDLEWARE
// ============================================
jobSchema.pre('save', function(next) {
  // Auto-generate storage metadata key if not provided
  if (this.metadata && !this.storageMetadata.key) {
    this.storageMetadata.key = `${this.metadata.video_owner}/${this.metadata.video_permlink}/video`;
  }
  
  next();
});

// ============================================
// POST-SAVE MIDDLEWARE
// ============================================
jobSchema.post('save', function(doc) {
  // Log important status changes
  if (this.isModified('status')) {
    console.log(`ðŸ“‹ Job ${doc.id} status changed to: ${doc.status}`);
  }
});

// ============================================
// MODEL CREATION WITH DYNAMIC CONNECTION
// ============================================
const createModel = () => {
  const { encoderDb } = require('../config/database');
  if (!encoderDb) {
    throw new Error('Encoder database connection not established');
  }
  return encoderDb.model('Job', jobSchema);
};

module.exports = createModel;